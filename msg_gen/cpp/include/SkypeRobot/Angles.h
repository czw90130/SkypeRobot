/* Auto-generated by genmsg_cpp for file /home/user/ros_workspace/sandbox/SkypeRobot/msg/Angles.msg */
#ifndef SKYPEROBOT_MESSAGE_ANGLES_H
#define SKYPEROBOT_MESSAGE_ANGLES_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace SkypeRobot
{
template <class ContainerAllocator>
struct Angles_ {
  typedef Angles_<ContainerAllocator> Type;

  Angles_()
  : TrackedNum(0)
  , HeadH(0)
  , HeadV(0)
  , ShoulderSpin(0)
  , ShoulderElbowXLeft(0)
  , ShoulderElbowYLeft(0)
  , ElbowSpinLeft(0)
  , ShoulderElbowWristLeft(0)
  , WristSpinLeft(0)
  , ElbowWristHandLeft(0)
  , ShoulderElbowXRight(0)
  , ShoulderElbowYRight(0)
  , ElbowSpinRight(0)
  , ShoulderElbowWristRight(0)
  , WristSpinRight(0)
  , ElbowWristHandRight(0)
  , HandXLeft(0)
  , HandYLeft(0)
  , HandXRight(0)
  , HandYRight(0)
  {
  }

  Angles_(const ContainerAllocator& _alloc)
  : TrackedNum(0)
  , HeadH(0)
  , HeadV(0)
  , ShoulderSpin(0)
  , ShoulderElbowXLeft(0)
  , ShoulderElbowYLeft(0)
  , ElbowSpinLeft(0)
  , ShoulderElbowWristLeft(0)
  , WristSpinLeft(0)
  , ElbowWristHandLeft(0)
  , ShoulderElbowXRight(0)
  , ShoulderElbowYRight(0)
  , ElbowSpinRight(0)
  , ShoulderElbowWristRight(0)
  , WristSpinRight(0)
  , ElbowWristHandRight(0)
  , HandXLeft(0)
  , HandYLeft(0)
  , HandXRight(0)
  , HandYRight(0)
  {
  }

  typedef int16_t _TrackedNum_type;
  int16_t TrackedNum;

  typedef int16_t _HeadH_type;
  int16_t HeadH;

  typedef int16_t _HeadV_type;
  int16_t HeadV;

  typedef int16_t _ShoulderSpin_type;
  int16_t ShoulderSpin;

  typedef int16_t _ShoulderElbowXLeft_type;
  int16_t ShoulderElbowXLeft;

  typedef int16_t _ShoulderElbowYLeft_type;
  int16_t ShoulderElbowYLeft;

  typedef int16_t _ElbowSpinLeft_type;
  int16_t ElbowSpinLeft;

  typedef int16_t _ShoulderElbowWristLeft_type;
  int16_t ShoulderElbowWristLeft;

  typedef int16_t _WristSpinLeft_type;
  int16_t WristSpinLeft;

  typedef int16_t _ElbowWristHandLeft_type;
  int16_t ElbowWristHandLeft;

  typedef int16_t _ShoulderElbowXRight_type;
  int16_t ShoulderElbowXRight;

  typedef int16_t _ShoulderElbowYRight_type;
  int16_t ShoulderElbowYRight;

  typedef int16_t _ElbowSpinRight_type;
  int16_t ElbowSpinRight;

  typedef int16_t _ShoulderElbowWristRight_type;
  int16_t ShoulderElbowWristRight;

  typedef int16_t _WristSpinRight_type;
  int16_t WristSpinRight;

  typedef int16_t _ElbowWristHandRight_type;
  int16_t ElbowWristHandRight;

  typedef int16_t _HandXLeft_type;
  int16_t HandXLeft;

  typedef int16_t _HandYLeft_type;
  int16_t HandYLeft;

  typedef int16_t _HandXRight_type;
  int16_t HandXRight;

  typedef int16_t _HandYRight_type;
  int16_t HandYRight;


  typedef boost::shared_ptr< ::SkypeRobot::Angles_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::SkypeRobot::Angles_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct Angles
typedef  ::SkypeRobot::Angles_<std::allocator<void> > Angles;

typedef boost::shared_ptr< ::SkypeRobot::Angles> AnglesPtr;
typedef boost::shared_ptr< ::SkypeRobot::Angles const> AnglesConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::SkypeRobot::Angles_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::SkypeRobot::Angles_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace SkypeRobot

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::SkypeRobot::Angles_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::SkypeRobot::Angles_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::SkypeRobot::Angles_<ContainerAllocator> > {
  static const char* value() 
  {
    return "961f4b7ebde630ec3d43d34559d7d4da";
  }

  static const char* value(const  ::SkypeRobot::Angles_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x961f4b7ebde630ecULL;
  static const uint64_t static_value2 = 0x3d43d34559d7d4daULL;
};

template<class ContainerAllocator>
struct DataType< ::SkypeRobot::Angles_<ContainerAllocator> > {
  static const char* value() 
  {
    return "SkypeRobot/Angles";
  }

  static const char* value(const  ::SkypeRobot::Angles_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::SkypeRobot::Angles_<ContainerAllocator> > {
  static const char* value() 
  {
    return "int16    TrackedNum\n\
int16	 HeadH\n\
int16    HeadV\n\
int16    ShoulderSpin\n\
int16    ShoulderElbowXLeft\n\
int16    ShoulderElbowYLeft\n\
int16    ElbowSpinLeft\n\
int16    ShoulderElbowWristLeft\n\
int16    WristSpinLeft\n\
int16    ElbowWristHandLeft\n\
int16    ShoulderElbowXRight\n\
int16    ShoulderElbowYRight\n\
int16    ElbowSpinRight\n\
int16    ShoulderElbowWristRight\n\
int16    WristSpinRight\n\
int16    ElbowWristHandRight\n\
int16    HandXLeft\n\
int16    HandYLeft\n\
int16    HandXRight\n\
int16    HandYRight\n\
\n\
";
  }

  static const char* value(const  ::SkypeRobot::Angles_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::SkypeRobot::Angles_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::SkypeRobot::Angles_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.TrackedNum);
    stream.next(m.HeadH);
    stream.next(m.HeadV);
    stream.next(m.ShoulderSpin);
    stream.next(m.ShoulderElbowXLeft);
    stream.next(m.ShoulderElbowYLeft);
    stream.next(m.ElbowSpinLeft);
    stream.next(m.ShoulderElbowWristLeft);
    stream.next(m.WristSpinLeft);
    stream.next(m.ElbowWristHandLeft);
    stream.next(m.ShoulderElbowXRight);
    stream.next(m.ShoulderElbowYRight);
    stream.next(m.ElbowSpinRight);
    stream.next(m.ShoulderElbowWristRight);
    stream.next(m.WristSpinRight);
    stream.next(m.ElbowWristHandRight);
    stream.next(m.HandXLeft);
    stream.next(m.HandYLeft);
    stream.next(m.HandXRight);
    stream.next(m.HandYRight);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct Angles_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::SkypeRobot::Angles_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::SkypeRobot::Angles_<ContainerAllocator> & v) 
  {
    s << indent << "TrackedNum: ";
    Printer<int16_t>::stream(s, indent + "  ", v.TrackedNum);
    s << indent << "HeadH: ";
    Printer<int16_t>::stream(s, indent + "  ", v.HeadH);
    s << indent << "HeadV: ";
    Printer<int16_t>::stream(s, indent + "  ", v.HeadV);
    s << indent << "ShoulderSpin: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderSpin);
    s << indent << "ShoulderElbowXLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderElbowXLeft);
    s << indent << "ShoulderElbowYLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderElbowYLeft);
    s << indent << "ElbowSpinLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ElbowSpinLeft);
    s << indent << "ShoulderElbowWristLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderElbowWristLeft);
    s << indent << "WristSpinLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.WristSpinLeft);
    s << indent << "ElbowWristHandLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ElbowWristHandLeft);
    s << indent << "ShoulderElbowXRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderElbowXRight);
    s << indent << "ShoulderElbowYRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderElbowYRight);
    s << indent << "ElbowSpinRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ElbowSpinRight);
    s << indent << "ShoulderElbowWristRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ShoulderElbowWristRight);
    s << indent << "WristSpinRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.WristSpinRight);
    s << indent << "ElbowWristHandRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ElbowWristHandRight);
    s << indent << "HandXLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.HandXLeft);
    s << indent << "HandYLeft: ";
    Printer<int16_t>::stream(s, indent + "  ", v.HandYLeft);
    s << indent << "HandXRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.HandXRight);
    s << indent << "HandYRight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.HandYRight);
  }
};


} // namespace message_operations
} // namespace ros

#endif // SKYPEROBOT_MESSAGE_ANGLES_H

